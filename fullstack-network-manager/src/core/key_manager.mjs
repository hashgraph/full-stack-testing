import fs from "fs";
import forge from "node-forge"
import path from "path";
import {FullstackTestingError, IllegalArgumentError, MissingArgumentError} from "./errors.mjs";
import {constants} from "./index.mjs";
import {Logger} from "./logging.mjs";
import {Templates} from "./templates.mjs";

export class KeyManager {
  constructor(logger) {
    if (!logger || !(logger instanceof Logger)) throw new MissingArgumentError('An instance of core/Logger is required')
    this.logger = logger
  }

  /**
   * Generates an RSA public-private key pair in a single call.
   *
   * It defaults to 3072 bits keys
   *
   * @returns an object with privateKey and publicKey properties
   */
  KeyPair() {
    const keypair = forge.pki.rsa.generateKeyPair(constants.PFX_KEY_BITS)

    // construct our own object before returning
    return {
      privateKey: keypair.privateKey,
      publicKey: keypair.publicKey,
    }
  }

  /**
   * Generate a certificate
   *
   * @param nodeId node ID
   * @param keypair RSA keypair as generated by KeyPair()
   * @param friendlyName common name (CN) for the subject name
   * @returns {*}
   * @constructor
   */

  Certificate(nodeId, keypair, friendlyName) {
    try {
      const cert = forge.pki.createCertificate();
      cert.publicKey = keypair.publicKey;
      cert.serialNumber = '01';
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 1);
      const attrs = [{
        shortName: 'CN',
        value: friendlyName,
      }];
      cert.setSubject(attrs);
      cert.setIssuer(attrs);

      // self-sign certificate
      cert.sign(keypair.privateKey);
      return cert
    } catch (e) {
      throw new FullstackTestingError(`failed to create certificate: ${e.message}`, e)
    }
  }

  /**
   * Generate node signing key
   *
   * It uses the following parameters:
   *  - Keypair: RSA, 3072 bits
   *  - pkcs12 Key encryption algo: aes256 // similar to keytool
   *  - pkcs12 MAC iteration: 10000 // similar to keytool
   *  - pkcs12 MAC salt length: 20 // similar to keytool
   *  - pkcs12 MAC algo: SHA1 // default, we cannot change it yet since the node-forge library hardcoded it
   *
   * @param nodeId
   * @param dir
   * @returns {string}
   */
  SigningKey(nodeId, dir) {
    if (!nodeId) throw new MissingArgumentError('nodeID is required')
    if (!dir) throw new MissingArgumentError('filePath is required')
    if (!fs.statSync(dir).isDirectory()) throw new IllegalArgumentError(`${dir} is not a valid path`)

    try {
      const friendlyName = Templates.renderSigningKeyFriendlyName(nodeId)
      const keypair = this.KeyPair()
      const cert = this.Certificate(nodeId, keypair, friendlyName)

      // FIXME, forge uses SHA1 for MAC instead of SHA256 as in openssl or keytool
      const p12Asn1 = forge.pkcs12.toPkcs12Asn1(keypair.privateKey, cert, constants.PFX_DUMMY_PASSWORD, {
        count: constants.PFX_MAC_ITERATION_COUNT,
        saltSize: constants.PFX_MAC_SALT_SIZE,
        algorithm: constants.PFX_ENCRYPTION_ALGO, // encryption algorithm, not macAlgorithm
        friendlyName: friendlyName,
      })
      const p12Der = forge.asn1.toDer(p12Asn1).getBytes();

      const filePath = path.join(dir, Templates.renderSigningKeyFileName(nodeId))
      fs.writeFileSync(filePath, p12Der, {encoding: 'binary'})
      return filePath
    } catch (e) {
      throw new FullstackTestingError(`failed to generate signing key for node '${nodeId}': ${e.message}`, e)
    }
  }
}